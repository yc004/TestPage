<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>测试页面</title>
    <link rel="stylesheet" href="Test.css">
    <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>

</head>
<body>
<canvas id="myCanvas" width="600" height="400">当前浏览器不支持canvas</canvas>
<nav class="canvasTools" id="toolBox">
    <input type="button" value="开始" onclick="" id="start" class="canvasTool"><br>
    <input type="button" value="暂停" onclick="" id="pause" class="canvasTool">
</nav>

<script>
    let mainCanvas = document.getElementById('myCanvas');
    let nav = document.getElementById('toolBox');
    let context = mainCanvas.getContext('2d');
    context.fillRect(0, 0, 600, 400);

    // 实时调整canvas画布的大小
    $(function () {
        $(window).resize(resizeCanvas);
        resizeCanvas();
    });

    function resizeCanvas() {
        $('#myCanvas').attr('width', $(window).get(0).innerWidth)
            .attr('height', $(window).get(0).innerHeight);
        // 每次调整完大小后重绘背景
        drawBG();
    }

    // 游戏主循环
    let BGposition = mainCanvas.width;
    let direction = false; // 物体移动方向
    let speed = 5; // 物体移动速度
    let size = {width: 100, height: 100} // 物体尺寸


    let mainLoop;

    function gameMainLoop() {
        let tempWidth = size.width;

/*
        // 物体在碰撞到墙壁时的缓冲压缩效果
        function buff(direction) {
            context.fillStyle = 'pink';
            context.fillRect(BGposition, mainCanvas.height / 2, tempWidth, size.height);
            tempWidth = direction ? tempWidth - 3 : tempWidth + 3;

            if (tempWidth <= 0) {
                cancelAnimationFrame(this);
            }
            requestAnimationFrame(buff);
        }
*/

        context.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
        drawBG();
        if (BGposition <= nav.offsetWidth || BGposition + 100 >= mainCanvas.width) {
            direction = !direction;
            // requestAnimationFrame(buff);
        }
        if (direction) {
            BGposition += speed;
        } else {
            BGposition -= speed;
        }
        context.fillStyle = 'pink';
        context.fillRect(BGposition, mainCanvas.height / 2, size.width, size.height);
        mainLoop = requestAnimationFrame(gameMainLoop);
    }


    // 绘制背景
    function drawBG() {
        context.fillStyle = '#000000';
        context.fillRect(0, 0, mainCanvas.width, mainCanvas.height);
    }

    document.getElementById('start').addEventListener('click', () => {
        requestAnimationFrame(gameMainLoop);
    });

    document.getElementById('pause').addEventListener('click', () => {
        cancelAnimationFrame(mainLoop);
    });


</script>
</body>
</html>